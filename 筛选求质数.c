/*
说明除了自身之外，无法被其它整数整除的数称之为质数，要求质数很简单，但如何快速的
求出质数则一直是程式设计人员与数学家努力的课题，在这边介绍一个着名的Eratosthenes求质
数方法。
解法首先知道这个问题可以使用回圈来求解，将一个指定的数除以所有小于它的数，若可以
整除就不是质数，然而如何减少回圈的检查次数？如何求出小于N的所有质数？
首先假设要检查的数是N好了，则事实上只要检查至N的开根号就可以了，道理很简单，假设
A*B = N，如果A大于N的开根号，则事实上在小于A之前的检查就可以先检查到B这个数可以整
除N。不过在程式中使用开根号会精确度的问题，所以可以使用i*i <= N进行检查，且执行更快。
再来假设有一个筛子存放1～N，例如：
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
........
N
先将2的倍数筛去：
2
3
5
7
9
11
13
15
17
19
21
........
N
再将3的倍数筛去：
2
3
5
7
11
13
17
19
........
N
再来将5的倍数筛去，再来将7的质数筛去，再来将11的倍数筛去........，如此进行到最后留下的
数就都是质数，这就是Eratosthenes筛选方法（Eratosthenes Sieve Method）。
检查的次数还可以再减少，事实上，只要检查6n+1与6n+5就可以了，也就是直接跳过2与3的倍
数，使得程式中的if的检查动作可以减少。

*/

#include <stdio.h>
#include <stdlib.h>

#define N 100000

int main(void)
{
    int i, j;
    int prime[N+1];

    for(i = 2; i <= N; i++)
        prime[i] = 1;

    for(i = 2; i * i <= N; i++){
        //可以改进
        if(prime[i] == 1){
            for(j = 2 * i; j <= N; j++){
                if(j % i == 0)
                    prime[j] = 0;
            }
        }
    }

    for(i = 2; i < N; i++){
        if(prime[i] == 1){
            printf("%10d", i);
            if(i % 16 == 0)
                printf("\n");
        }
    }

    printf("\n");
    return 0;
}
